package chc;

import java.math.BigInteger;
import java.util.Random;
import java.util.Scanner;


public class Merkle_Hellman_Knapsack {
    private SinglyLinkedList w;
    private SinglyLinkedList b;
    private BigInteger q;
    private BigInteger r;

    private static final int Wlength = 640;

    /**
     * Initialize the Merkel_Hellman_knapsack
     */
    public Merkle_Hellman_Knapsack() {
        w = new SinglyLinkedList();
        b = new SinglyLinkedList();
        q = BigInteger.valueOf(0);
        r = BigInteger.valueOf(0);
        getParameter();
    }


    /**
     * Initialize the parameters including w, b, q and r
     */
    public void getParameter() {
        Random rnd = new Random();
        BigInteger sum = BigInteger.valueOf(0);
        String[] data = {"2", "7", "11", "21", "42", "89", "180", "354"};

        for (int i = 0; i < data.length; i++) {
            BigInteger temp = new BigInteger(data[i]);
            w.addAtEndNode(temp);
            sum = sum.add(temp);
        }

//        BigInteger prev_sum;
        for (int i = data.length; i < Wlength; i++) {
//            prev_sum = sum;
            BigInteger rd = BigInteger.valueOf((rnd.nextInt(4) + 1));
            BigInteger x = sum.add(rd);
            w.addAtEndNode(x);
            sum = sum.add(x);
        }

        do {
            q = sum.add(new BigInteger(sum.bitLength(), new Random()));
        } while(q.equals(sum));

        r = getR(q);

        getB();
    }

    public void getB() {
        w.reset();
        while (w.hasNext()) {
            BigInteger temp = (BigInteger) w.next();
            b.addAtEndNode(temp.multiply(r).mod(q));
        }
    }

    public BigInteger getR(BigInteger v) {
        BigInteger temp = v.subtract(BigInteger.valueOf(1));

        while (temp.compareTo(BigInteger.valueOf(1)) > 0) {
            if (v.gcd(temp).equals(BigInteger.valueOf(1))) {
                break;
            } else {
                temp = temp.subtract(BigInteger.valueOf(1));
            }
        }

        if (temp.equals(BigInteger.valueOf(1))) {
            throw new ArithmeticException("Couldn't find the coprime of " + v);
        }

        return temp;
    }

    /**
     * Encrypt the input string
     * @param vt
     *  the input string from system.in
     * @return
     *  the string generated from encrypting inputs
     */
    public String encryptionString(String vt) {
//        StringBuilder encryption = new StringBuilder();
        StringBuilder vtString = new StringBuilder();
        BigInteger sum = BigInteger.valueOf(0);
        int index = 0;

        for (int i = 0; i < vt.length(); i++) {
            String val = Integer.toBinaryString((int)vt.charAt(i));

            if (val.length() < 8) {
                vtString.delete(0, vtString.length());
                for (int j = 0; j < 8 - val.length(); j++) {
                    vtString.append('0');
                }
                vtString.append(val);
                val = vtString.toString();
            }

            for (int k = 0; k < 8; k++) {
                if (val.charAt(k) == '1') {
                    sum = sum.add((BigInteger)b.getObjectAt(index));
                }
                index += 1;
            }
        }
        return sum.toString();
    }

    /**
     * decrypt the string which is generated by encrypting inputs
     * @param v
     *  the generated string from encrypting inputs
     * @return
     *  the decrypted string
     */
    public String decrypt(String v) {
        BigInteger rInv = r.modInverse(q);
        BigInteger sum = new BigInteger(v);
        BigInteger decryptResult = sum.multiply(rInv).mod(q);

        SinglyLinkedList decryRes = new SinglyLinkedList();
        int index = Wlength - 1, leftBound = -1;
        int upperBound = 0;
        while (decryptResult.compareTo(BigInteger.valueOf(0)) > 0 && index > leftBound) {
            BigInteger indexAtW = (BigInteger) w.getObjectAt(index);
            if (decryptResult.compareTo(indexAtW) >= 0) {
                decryptResult = decryptResult.subtract(indexAtW);
                decryRes.addAtFrontNode('1');
                if (upperBound < index) {
                    upperBound = index;
                }
            } else {
                decryRes.addAtFrontNode('0');
            }
            index -= 1;
        }

        while (index > leftBound) {
            decryRes.addAtFrontNode('0');
            index -= 1;
        }

        decryRes.reset();
        StringBuilder res = new StringBuilder();
        StringBuilder tempString = new StringBuilder();
        int i = 0;

        while (decryRes.hasNext() && i <= (upperBound + 7)) {
            tempString.append(decryRes.next());
            i += 1;
            if (i % 8 == 0) {
                res.append((char)Integer.parseInt(tempString.toString(), 2));
                tempString.delete(0, 8);
            }
        }
        return res.toString();

    }



    public static void main(String[] args) {
        Merkle_Hellman_Knapsack cryp = new Merkle_Hellman_Knapsack();
        Scanner scanner = new Scanner(System.in);

        for(; ; ) {
            System.out.println("Enter a string and I will encrypt it as single large integer.");
            String data = scanner.nextLine();
            if (data.length() > 80) {
                System.out.println("The input should be no more than 80 characters, try again!");
                continue;
            }
            System.out.println("Clear text:");
            System.out.println(data);
            System.out.println("Number of clear text bytes = " + data.length());
            String encryptString = cryp.encryptionString(data);
            System.out.printf("%s is encrypted as\n", data);
            System.out.println(encryptString);
            String decryString = cryp.decrypt(encryptString);
            System.out.printf("Result of decryption: %s\n", decryString);
        }
    }
}
